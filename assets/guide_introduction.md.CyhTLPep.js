import{_ as r}from"./chunks/test-coverage.DdJGYyGo.js";import{_ as s}from"./chunks/eventsourcing.BDo82Kkz.js";import{_ as n}from"./chunks/bi.Bw6fcjbs.js";import{_ as p}from"./chunks/Architecture.BSF8rJcK.js";import{_ as c,D as m,c as d,I as t,w as i,j as e,a as h,a4 as l,o as _}from"./chunks/framework.CXozoTLq.js";const u="/wow/assets/logo.DHQVy3Mt.svg",w="/wow/assets/Features.CCSUi9mf.png",N=JSON.parse('{"title":"简介","description":"","frontmatter":{},"headers":[],"relativePath":"guide/introduction.md","filePath":"guide/introduction.md","lastUpdated":1721086461000}'),g={name:"guide/introduction.md"},W=e("h1",{id:"简介",tabindex:"-1"},[h("简介 "),e("a",{class:"header-anchor",href:"#简介","aria-label":'Permalink to "简介"'},"​")],-1),b=e("img",{width:"150",src:u,alt:"Wow:基于 DDD、EventSourcing 的现代响应式 CQRS 架构微服务开发框架"},null,-1),f={class:"info custom-block"},x=e("p",{class:"custom-block-title"},"Keywords",-1),C=l('<p><em>Wow</em> 是一个基于领域驱动设计和事件溯源的现代响应式 <em>CQRS</em> 微服务开发框架，历经多年生产环境验证。</p><p>旨在帮助开发者构建现代化的、高性能且易于维护的微服务应用程序，充分发挥领域驱动设计和事件溯源等模式优势的同时降低应用的复杂性以及实践成本。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>值得一提的是，领域驱动设计和事件溯源并非微服务架构的专属，<em>Wow</em> 框架不仅适用于微服务开发，同样也可用于构建基于领域驱动设计的单体应用程序。</p></div><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>随着业务的发展和复杂性的增加，传统的架构和开发方式逐渐显露出瓶颈。<em>领域驱动设计</em>和<em>事件溯源</em>等理念在提高系统设计的灵活性和可维护性方面表现出色，但在实践中常常需要面对复杂性和学习曲线的挑战。</p><p><em>Wow</em> 框架的目标是以简单易用的方式将领域驱动设计和事件溯源等理念融入到微服务应用开发中，降低开发者的学习成本，提高开发效率。 通过提供现代响应式的 <em>CQRS</em> 架构和相关组件，<em>Wow</em> 框架旨在让开发者更专注于业务逻辑的实现，而不必过多关心底层技术细节。</p><p>经过多年的实践和不断的演进，<em>Wow</em> 框架在生产环境中得到了验证，积累了丰富的经验。这些经验和反馈不仅丰富了框架的功能和性能，也为持续的改进和优化提供了宝贵的指导。</p><h2 id="对于开发者而言-wow-框架意味着什么" tabindex="-1">对于开发者而言，<em>Wow</em> 框架意味着什么？ <a class="header-anchor" href="#对于开发者而言-wow-框架意味着什么" aria-label="Permalink to &quot;对于开发者而言，_Wow_ 框架意味着什么？&quot;">​</a></h2><p>我曾告诫我的团队：如果我们过于依赖<em>数据驱动设计</em>而忽视<em>领域驱动设计</em>，我们最终将沦为<em>CRUD</em>工程师。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><em>CRUD</em>工程师的竞争力和可替代性可想而知，这或许是为何会有 <em>35</em> 岁效应，企业显然更倾向于招募没有太多生活羁绊、更加廉价的 <em>25</em> 岁<em>CRUD</em>工程师。</p></div><h3 id="业务价值" tabindex="-1">业务价值 <a class="header-anchor" href="#业务价值" aria-label="Permalink to &quot;业务价值&quot;">​</a></h3><p>软件系统的核心价值体现在业务价值上，研发人员不应只关注技术实现上，而是应该更多地关注业务价值的实现。 这其中的好处显而易见，当你开发完一个业务系统之后，你将变成一个业务专家，甚至比跟你合作的领域专家还要专业，因为你需要洞察业务细节。</p><p>使用 <em>Wow</em> 框架，意味着你将关注点放在围绕领域模型设计上，与业务专家一起探索业务领域，而不是关注于技术实现上。 你仅需编写领域模型，即可完成服务开发，<em>Wow</em> 框架自动为你准备好 <em>OpenAPI</em> 接口。</p><blockquote><p>在《实现领域驱动设计》一书中，作者 Vaughn Vernon 提到：核心域才值得投入精力进行领域驱动设计， 但如果你使用 <em>Wow</em> 框架，你将发现，因为低廉开发成本、快速的开发效率，即使是次要的支撑子域也值得 <em>DDD</em>。</p></blockquote><h3 id="性能与伸缩性" tabindex="-1">性能与伸缩性 <a class="header-anchor" href="#性能与伸缩性" aria-label="Permalink to &quot;性能与伸缩性&quot;">​</a></h3><p>随着业务的发展，你需要开始思考系统的性能和伸缩性问题。 在传统架构中，这牵扯到数据库关系模式、分片规则等复杂问题，同时你还需要处理因数据库分片导致的跨分片事务问题。 这时，你不得不修改你的业务代码，以适应水平拆分后的数据库架构。</p><p>然而，如果你选择使用 <em>Wow</em> 框架，你将不再需要过多关注数据库关系模式、分片规则等问题。你的业务代码无需变更，系统能够轻松实现水平伸缩。</p><p>你可以在这里了解更多关于 <a href="/wow/guide/perf-test.html">Wow 框架的性能</a>。</p><h3 id="读写分离与同步延迟" tabindex="-1">读写分离与同步延迟 <a class="header-anchor" href="#读写分离与同步延迟" aria-label="Permalink to &quot;读写分离与同步延迟&quot;">​</a></h3><p>读写分离是一种极为普遍的性能优化架构模式。 然而，同步延迟问题常伴随而来，事务执行成功后写库落库成功，但读库同步延迟，用户刷新页面后无法获取最新数据，从而对用户的体验产生影响。例如：</p><ul><li>用户发起下单事务，写库执行成功，但由于某种原因，读库同步延迟，用户刷新页面后发现订单未成功创建。</li><li>商家编辑完商品后，同步到 <em>Elasticsearch</em> 索引库，但由于某种原因，同步延迟，导致商家刷新页面后搜索不到该商品。</li></ul><p>通常，大家采用最简便的方法，等待1秒后刷新页面。 虽然这种方式能解决大多数数据同步延迟的问题，但效率不够高。 因为大多数情况下，同步在100毫秒内就已完成，剩余的900毫秒成了<em>浪费</em>。 然而，有时1秒无法完成同步，这就导致用户获取的数据变得<strong>无效</strong>。</p><p>使用 <em>Wow</em> 框架，你可以通过等待 <em>PROJECTED</em> 信号完成，然后再将结果返回给用户，以更为优雅和高效的方式处理数据同步延迟的问题。</p><p>了解更多关于 <a href="/wow/guide/command-gateway.html#等待策略">命令等待策略</a>。</p><h3 id="工程质量" tabindex="-1">工程质量 <a class="header-anchor" href="#工程质量" aria-label="Permalink to &quot;工程质量&quot;">​</a></h3><p><img src="'+r+'" alt="Test Coverage"></p><p><em>单元测试</em>是确保代码质量且符合预期业务需求的重要手段，但在传统架构中，单元测试往往是一项相当困难的任务，因为你需要考虑数据库连接、事务管理、数据清理等问题。</p><p>使用 <em>Wow</em> 框架，你将会发现基于 <em>Given-&gt;When-&gt;Expect</em> 模式的测试套件，使得单元测试变得异常简单。 你只需关注领域模型是否符合预期，而无需为数据库连接等问题烦恼。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在实际应用中，我们将领域模型的单元测试覆盖率下限阈值设置为 <strong>85%</strong>，也是可以轻松实现的。 在没有刻意要求的情况下，开发人员甚至自觉地将覆盖率提升至 <strong>95%</strong>。 因此，每次提交代码都变得轻松自在，因为你确信你的代码经过了充分的测试，并且真正意义上从单元测试中获得了收益。</p></div><p>在研发同级别的项目中，我们的测试团队在系统 <em>API</em> 测试中发现，基于 Wow 框架的项目，其 <em>BUG</em> 数仅为传统架构项目的 <strong>1/3</strong>。</p><p>你可以在这里了解更多关于 <a href="/wow/guide/test-suite.html">Wow 单元测试套件</a>。</p><h2 id="对于企业而言-wow-框架意味着什么" tabindex="-1">对于企业而言，<em>Wow</em> 框架意味着什么？ <a class="header-anchor" href="#对于企业而言-wow-框架意味着什么" aria-label="Permalink to &quot;对于企业而言，_Wow_ 框架意味着什么？&quot;">​</a></h2><h3 id="商业智能" tabindex="-1">商业智能 <a class="header-anchor" href="#商业智能" aria-label="Permalink to &quot;商业智能&quot;">​</a></h3><p><em>商业智能</em>是企业决策的关键支持，而数据则是商业智能的分析原料。业务数据越为丰富有价值，商业智能的分析结果越准确，决策也就更加可靠。</p><p>与传统架构有着显著差异，<em>Wow</em> 提供了实时聚合根状态事件（<code>StateEvent</code>）和聚合命令（<code>Command</code>）作为数据分析的数据源，同时极大降低了实时 <em>ETL</em>（<code>Extract</code>, <code>Transform</code>, <code>Load</code>）的难度。</p>',35),k=e("p",null,[e("img",{src:s,alt:"事件溯源 VS 传统架构"})],-1),q=l('<p>在传统架构中，实现实时 <em>ETL</em> 通常需要经过繁琐的流程，包括 <code>DB-&gt;CDC-&gt;Process-&gt;DB</code>，而在 <em>Wow</em> 框架中，仅需一段简单的 <em>SQL</em> 脚本即可完成这一过程。</p><p><img src="'+n+'" alt="商业智能"></p><p>另外，在传统架构中，使用 <em>CDC</em>（<code>MySql Binlog</code>）数据仅记录数据的变化，缺乏明确的业务语义。进行业务分析时，需要基于数据状态的变化推断出业务语义，这往往需要进行大量的数据处理。 相较之下，<em>Wow</em> 框架直接提供了聚合根状态事件和聚合命令作为数据分析的数据源，极大降低了数据处理的难度。</p><p><em>Wow</em> 提供的实时同步机制将数据实时同步至数据仓库（<em>ClickHouse</em>），为实时数据分析提供了极大的便利。这种方法为商业智能提供了强有力的支持，构建了一个实时数据分析系统，使决策制定能够基于及时而准确的信息。</p><p>你可以在这里了解更多关于 <a href="/wow/guide/bi.html">Wow 商业智能</a>。</p><h3 id="操作审计" tabindex="-1">操作审计 <a class="header-anchor" href="#操作审计" aria-label="Permalink to &quot;操作审计&quot;">​</a></h3><p><em>操作审计</em>是企业中保障安全性和合规性的重要组成部分，同时也是对系统操作进行监控和追踪的关键手段。<em>Wow</em> 框架在这方面为企业带来了显著的优势。</p><p>通过记录聚合命令（<code>Command</code>）作为操作审计的数据源，<em>Wow</em> 框架能够详细追踪系统中的各种操作。 这些记录不仅包含了操作本身的内容，还涵盖了操作触发的副作用（<em>领域事件</em>），为审计提供了更为全面和准确的数据基础。</p><p>相较于传统审计方法，<em>Wow</em> 框架的操作审计的数据源具备更加明确的业务语义，以及操作后产生的明确领域事件。</p><p>此外，Wow 框架提供的实时数据同步机制也为操作审计带来了便利，确保了审计数据的及时性和一致性。</p><p>了解更多关于 <a href="/wow/guide/bi.html#聚合命令">Wow 操作审计</a>。</p><h2 id="wow-提供了哪些特性" tabindex="-1"><em>Wow</em> 提供了哪些特性？ <a class="header-anchor" href="#wow-提供了哪些特性" aria-label="Permalink to &quot;_Wow_ 提供了哪些特性？&quot;">​</a></h2><p>在 <em>Wow</em> 框架中，有许多关键特性，包括但不限于：</p><ul><li>命令网关：<em>CQRS</em> 模式中命令响应通常是一个简单的确认，告知客户端写操作已经成功处理（聚合根处理阶段），此时客户端刷新页面很可能无法获取到数据（投影查询模型到查询数据库尚未完成）。这对于客户端来说是非常不友好的。 为了解决该问题<em>Wow</em>提供了多种命令等待策略，如<code>PROJECTED</code>信号可以等待投影完成。</li><li>事件驱动：提供了事件总线来处理事件的发布和订阅，帮助实现松耦合的组件之间的通信，以及查询模型的投影。</li><li>聚合根建模：采用聚合根来组织和管理领域模型，帮助开发者更好地划分和管理业务逻辑。</li><li>事件溯源：通过记录和回放事件来还原和跟踪应用程序状态变化，实现了强大的数据历史记录和审计功能。</li><li>命令查询职责分离：将读写操作分开，提升了系统性能和灵活性。</li><li>响应式编程：基于响应式编程模型使系统更适应异步和并发操作，提高整体响应性能。通过异步消息传递，系统组件以非阻塞方式通信，降低系统开销、增强系统弹性，确保高负载和低负载时均能保持即时响应性。</li><li>分布式事务：利用 <em>Saga</em> 编排模式精心管理复杂多服务之间的事务流程，以降低分布式事务的复杂性</li><li>测试驱动：提供了测试套件，可轻松实现 <em>80%</em> 以上的测试覆盖率，助力开发者构建高质量应用。</li><li><em>Spring WebFlux</em> 集成：自动注册命令路由处理函数，专注于领域模型的开发。</li><li><em>Spring Boot</em> 集成：与 <em>Spring Boot</em> 完美集成，简化组件装配，加速微服务的开发。</li><li>可观测性：相较于传统的单一模式，<em>CQRS</em> 模式在某些方面可能会增加调试的复杂性。 这主要是因为 <em>CQRS</em> 引入了对写操作（命令）和读操作（查询）分离的设计，从而可能导致系统变得更加分散和复杂。 为了解决该问题，<em>Wow</em> 集成了 <em>OpenTelemetry</em> 以实现系统的端到端可观测性，有助于监控和调试。</li></ul><p align="center" style="text-align:center;"><img src="'+w+'" alt="Wow-Features"></p><h2 id="架构图" tabindex="-1">架构图 <a class="header-anchor" href="#架构图" aria-label="Permalink to &quot;架构图&quot;">​</a></h2><p align="center" style="text-align:center;"><img src="'+p+'" alt="Wow-Architecture"></p>',17);function P(S,T,D,v,y,E){const a=m("center"),o=m("Badge");return _(),d("div",null,[W,t(a,null,{default:i(()=>[b]),_:1}),e("div",f,[x,e("p",null,[e("strong",null,[t(o,{type:"tip",text:"领域驱动"})]),e("strong",null,[t(o,{type:"tip",text:"事件驱动"})]),e("strong",null,[t(o,{type:"tip",text:"测试驱动"})]),e("strong",null,[t(o,{type:"tip",text:"声明式设计"})]),e("strong",null,[t(o,{type:"tip",text:"响应式编程"})]),e("strong",null,[t(o,{type:"tip",text:"命令查询职责分离"})]),e("strong",null,[t(o,{type:"tip",text:"事件溯源"})])])]),C,t(a,null,{default:i(()=>[k]),_:1}),q])}const Q=c(g,[["render",P]]);export{N as __pageData,Q as default};
